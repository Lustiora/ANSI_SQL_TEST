# 1. 회원별 최근 대여 기록 조회

---

### DB : PostgreSQL Sample Database

---

## 1. 테이블 정보 (Schema)

**`customer`** (고객 정보)

* `customer_id`: **고객 ID** (PK)
* `last_name`: **고객의 성**

**`rental`** (대여 기록)

* `rental_id`: **대여 고유 ID** (PK)
* `customer_id`: **고객 ID** (FK)
* `inventory_id`: **재고 ID** (FK)
* `rental_date`: **대여 일시**

**`inventory`** (재고 정보)

* `inventory_id`: **재고 고유 ID** (PK)
* `film_id`: **영화 ID** (FK)

**`film`** (영화 정보)

* `film_id`: **영화 고유 ID** (PK)
* `title`: **영화 제목**

---

## 2. 문제 상황 (Scenario)

**[문제 사양]**
모든 고객에 대해, 그들이 **'가장 최근에'** 빌린 영화가 무엇인지 알고 싶습니다.
`rental` 테이블과 `inventory`, `film` 테이블을 연결하여, 각 고객 (`customer_id`) 별로 가장 마지막 대여 기록(1건)만 추출해 주세요.

1. **대상:** 모든 고객
2. **기준:** `rental_date` 가 가장 최신인 기록
3. **출력:** 고객 ID, 고객 성 (**Last Name**), 마지막으로 빌린 영화 제목 (`title`), 대여 일자 (`rental_date`)

---

## 3. 원하는 결과 (Expected Output)

* `customer_id` 를 기준으로 오름차순 정렬하세요.

| customer_id | last_name | title | rental_date |
| --- | --- | --- | --- |
| 1 | Smith | Bikini Borrowers | 2005-08-22 20:03:46.000 |
| 2 | Johnson | Open African | 2005-08-23 17:39:35.000 |
| 3 | Williams | Lucky Flying | 2005-08-23 07:10:14.000 |
| ... | ... | ... | ... |

---

#### 힌트 (고민을 돕는 질문)

* **DISTINCT ON 활용:** 보통 중복 제거할 때 `DISTINCT` 를 쓰지만, PostgreSQL에는 `DISTINCT ON (컬럼명)` 이라는 강력한 문법이 있습니다.
* "이 컬럼을 기준으로 중복을 없애되, 정렬 순서상 **맨 위에 있는 녀석 하나만 남겨라**"라는 뜻입니다. 이 기능을 사용하면 `ROW_NUMBER()` 나 복잡한 `MAX()` 서브쿼리 없이 아주 우아하게 문제를 풀 수 있습니다.
* **문법 구조:** `SELECT DISTINCT ON (기준컬럼) ... ORDER BY 기준컬럼, 정렬기준 DESC`
* **주의사항:** `DISTINCT ON` 에 쓴 컬럼은 반드시 `ORDER BY` 의 **가장 첫 번째** 에 와야 합니다.

---

# 2. 고객별 평균 재구매 주기 산출

---

### DB : Oracle Sample Database

---

## 1. 테이블 정보 (Schema)

**`orders`** (주문 내역)

* `order_id`: **주문 번호** (PK)
* `user_id`: **주문한 고객 ID** (FK)
* `order_date`: **주문 일자** (Date 타입)
* `total_amount`: **주문 총액**

---

## 2. 문제 상황 (Scenario)

**[문제 사양]**
우리 쇼핑몰 고객들은 평균적으로 며칠 만에 다시 물건을 살까요?
**최소 2번 이상** 주문한 이력이 있는 고객들을 대상으로, **주문과 주문 사이의 간격 (일수, Days)** 을 구하고, 고객별로 그 간격들의 **평균** 을 구해주세요.

**[대상 고객]**

* 주문 건수가 **2건 이상** 인 고객만 포함합니다.

**[계산 로직]**

* 고객 A가 `1월 1일`, `1월 5일`, `1월 20일` 에 주문했다면?
* 첫 번째 간격: 5일 - 1일 = **4일**
* 두 번째 간격: 20일 - 5일 = **15일**
* **평균 재구매 주기:** (4 + 15) / 2 = **9.5일**



---

## 3. 원하는 결과 (Expected Output)

* `user_id` 를 기준으로 오름차순 정렬하세요.
* 소수점 첫째 자리까지만 **반올림** (ROUND) 하여 출력하세요.

| user_id | avg_cycle |
| --- | --- |
| 1 | 149.5 |
| 2 | 167 |
| 3 | 83 |
| ... | ... |

---

#### 힌트 (고민을 돕는 질문)

* **이전 행 (Previous Row) 가져오기:** 지금까지의 집계 (`GROUP BY`) 는 세로로 있는 데이터를 합치는 것이었지만, 이 문제는 **"현재 행 (이번 주문)"** 과 **"바로 직전 행 (지난 주문)"** 을 비교해야 합니다.
* **윈도우 함수:** `LAG(가져올컬럼) OVER (PARTITION BY 그룹기준 ORDER BY 정렬기준)` 를 사용하면 아주 쉽게 해결할 수 있습니다.
* **날짜 차이:** PostgreSQL에서는 `date_column - date_column` 결과가 정수(일수)로 나옵니다.
* **단계:** 서브쿼리(또는 CTE)에서 **'이전 주문일'** 을 먼저 구하고, 메인쿼리에서 차이의 평균을 구해보세요.

---

# 3. 일별 전체 매출 추세 모니터링 리포트

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`daily_sales`** (일별 매출 현황)

* `sales_date`: **판매 일자** (DATE)
* `amount`: **매출액** (NUMBER)

---

## 2. 문제 상황 (Scenario)

**[상황]**
CFO(재무 이사)가 매일 아침 리포트를 보는데, 일별 매출액 (`amount`) 이 들쑥날쑥해서 전체적인 추세를 파악하기 어렵다고 합니다.
아래 두 가지 지표를 추가하여 보고 싶어 합니다.

**[요구 사항]**
다음 4가지 컬럼을 출력하는 쿼리를 작성하세요.

1. `sales_date`: **판매 일자**
2. `amount`: **해당 일자의 매출액**
3. **누적 매출** (`running_total`): 1월 1일부터 **해당 날짜까지** 의 총매출 합계.
4. **3일 이동 평균** (`moving_avg`): 매출의 변동성을 줄이기 위해, **(그저께 + 어제 + 오늘) 3일간의 매출 평균** 을 구하세요.
* *예: 1월 3일의 이동 평균 = (1일 100 + 2일 200 + 3일 150) / 3 = 150*
* *1월 1일은 앞의 데이터가 없으니 자기 자신(100)만으로 평균.*



---

## 3. 원하는 결과 (Expected Output)

* `sales_date` 를 기준으로 오름차순 정렬하세요.

---

#### 힌트 (고민을 돕는 질문)

* **윈도우 함수의 기본 구조:** `함수() OVER (ORDER BY 정렬기준 [ROWS ...])`
* `GROUP BY` 와 다르게 행을 합치지 않고, 각 행마다 계산 결과를 붙여줍니다.


* **윈도우 프레임 (Window Frame):** `running_total` 과 `moving_avg` 의 결정적 차이는 **"계산 범위"** 입니다. 이 범위를 지정하는 문법이 **`ROWS BETWEEN ... AND ...`** 입니다.
* **누적 합:** `SUM(amount) OVER (ORDER BY sales_date)` 라고만 써도 기본적으로 "처음부터 현재 행까지"가 적용됩니다.
* **3일 이동 평균:** "현재 행(Current Row)"을 기준으로 "앞선 2개 행(2 Preceding)"까지를 범위로 잡아야 합니다.
* 문법: `AVG(amount) OVER (ORDER BY sales_date ROWS BETWEEN ??? AND ???)`
* `???` 자리에 들어갈 단어: `Preceding` (이전), `Following` (이후), `Current Row` (현재)

---

# 4. 부서별 급여 상위 구간 직원 현황

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`employees`** (직원 정보)

* `dept_name`: **부서명** (개발팀, 영업팀, 인사팀...)
* `emp_name`: **직원 이름**
* `salary`: **연봉**

---

## 2. 문제 상황 (Scenario)

**[상황]**
각 부서별로 **"연봉이 가장 높은 직원 1명씩"** 만 뽑아서 보고서를 만들려고 합니다.
(만약 부서 내 최고 연봉자가 2명이라면, 이름 가나다순으로 한 명만 뽑습니다.)

**[문제]**
`ROW_NUMBER()` 함수를 사용하여, **각 부서** (`dept_name`) **내에서 연봉** (`salary`) **이 높은 순서대로** 순번을 매기는 쿼리를 작성해 주세요.

* **결과 컬럼:** `dept_name`, `emp_name`, `salary`, `ranking`

```sql
SELECT
    dept_name,
    emp_name,
    salary,
    ROW_NUMBER() OVER (
        PARTITION BY ______  -- 부서별로 나눈다
        ORDER BY ______ DESC, ______ ASC -- 연봉 높은순, 이름순
    ) as ranking
FROM employees;

```

---

## 3. 원하는 결과 (Expected Output)

* `dept_name` 오름차순, `ranking` 오름차순 정렬

---

#### 힌트 (고민을 돕는 질문)

* **파티션 (Partition):** `OVER` 절 안에서 데이터를 그룹핑하는 기준입니다. 여기서는 **"부서별"** 로 순위를 매겨야 하므로 `PARTITION BY` 뒤에 어떤 컬럼이 와야 할까요?
* **정렬 (Order):**
1. **연봉** 이 높은 사람이 1등이어야 합니다. (`DESC`)
2. 연봉이 같을 경우 **이름** 순으로 정렬합니다. (`ASC`)

---

# 5. 일일 방문자 증감(Diff) 추이 분석

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`daily_report`** (일별 리포트)

* `report_date`: **날짜**
* `visitors`: **방문자 수**

---

## 2. 문제 상황 (Scenario)

**[상황]**
마케팅 팀에서 **"전날 대비 방문자가 몇 명이나 늘었는지 (혹은 줄었는지)"** 알고 싶어 합니다.

**[요구 사항]**
아래 3개 컬럼을 출력하세요.

1. `report_date`: **날짜**
2. `today_visitors`: **오늘 방문자 수**
3. **`diff` (증감 확인):** (오늘 방문자 수) - (어제 방문자 수)
* *예: 1월 2일의 diff = 150 - 100 = 50*
* *예: 1월 3일의 diff = 130 - 150 = -20*
* *1월 1일은 어제 데이터가 없으니 `NULL` 이어도 괜찮습니다.*



---

## 3. 원하는 결과 (Expected Output)

* `report_date` 를 기준으로 오름차순 정렬하세요.

---

#### 힌트 (고민을 돕는 질문)

* **LAG(컬럼명):** "내 바로 전 행의 값"을 가져옵니다.
* **LEAD(컬럼명):** "내 바로 다음 행의 값"을 가져옵니다.
* 우리는 **어제 (이전) 값** 이 필요합니다. 윈도우 함수 `OVER` 절 내부의 정렬 (`ORDER BY`) 은 무엇을 기준으로 해야 할까요?

---

# 6. 데이터 구조 변환

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`exam_scores`** (학생 성적표)

* `student_name`: **학생 이름**
* `math`: **수학 점수** (컬럼)
* `english`: **영어 점수** (컬럼)

| student_name | math | english |
| --- | --- | --- |
| **김철수** | **90** | **80** |
| **이영희** | **70** | **95** |

---

## 2. 문제 상황 (Scenario)

**[상황]**
성적 데이터가 과목별로 **컬럼** (`Math`, `English`) 으로 나뉘어 저장되어 있습니다. (Wide format)
데이터 분석을 위해 이 과목 구분이 컬럼이 아니라 **하나의 행 (Row)** 데이터로 내려와야 합니다.

**[요구 사항]**
`exam_scores` 테이블을 변환하여, 학생 한 명당 **과목별로 2개의 행** 이 생기도록 만드세요.
필요한 컬럼은 **`student_name`**, **`subject`** (과목명), **`score`** (점수) 입니다.

---

## 3. 원하는 결과 (Expected Output)

| student_name | subject | score |
| --- | --- | --- |
| 김철수 | Math | 90 |
| 김철수 | English | 80 |
| 이영희 | Math | 70 |
| 이영희 | English | 95 |

---

#### 힌트 (고민을 돕는 질문)

* **Wide to Long 변환:** 가로로 넓은 데이터를 세로로 길게 만드는 것을 **Unpivot** 이라고 합니다.
* **UNION ALL 활용:**
1. 먼저 `math` 점수만 뽑아서, 과목명을 `'Math'` 로 지정한 쿼리를 만듭니다.
2. 그 다음 `english` 점수만 뽑아서, 과목명을 `'English'` 로 지정한 쿼리를 만듭니다.
3. 이 두 쿼리를 **위아래로 붙이는 집합 연산자** 는 무엇일까요?

---

# 7. 일별 매출 합산 후 평균 지표 산출

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`daily_sales`** (일별 매출)

* `dt`: **날짜**
* `category`: **카테고리** (A, B)
* `sales`: **매출액**

| dt | category | sales |
| --- | --- | --- |
| 2024-01-01 | A | 100 |
| 2024-01-01 | B | 200 |
| 2024-01-02 | A | 150 |
| 2024-01-02 | B | 250 |

---

## 2. 문제 상황 (Scenario)

**[상황]**
경영진이 **"일 평균 매출액"** 을 알고 싶어 합니다.
그런데 데이터에는 카테고리별로 쪼개져 있어서, 먼저 **날짜별로 합산** 을 한 뒤에, 그 합산된 값들의 **평균** 을 구해야 합니다.

**[요구 사항]**

1. **서브쿼리 (`FROM` 절):** 먼저 날짜 (`dt`) 별로 매출 합계 (`daily_total`) 를 구하는 쿼리를 만드세요.
2. **메인쿼리:** 위 서브쿼리 결과를 테이블처럼 사용하여, `daily_total` 의 평균 (`AVG`) 을 구하세요.

**[계산 논리]**

1. 1월 1일 총매출: 100 + 200 = **300**
2. 1월 2일 총매출: 150 + 250 = **400**
3. **최종 결과:** (300 + 400) / 2 = **350**

---

## 3. 원하는 결과 (Expected Output)

| avg_daily_sales |
| --- |
| 350 |

---

#### 힌트 (고민을 돕는 질문)

* **Inline View (인라인 뷰):** `FROM` 절에 들어가는 서브쿼리를 마치 **"임시 테이블"** 처럼 생각하세요.
* **별칭 (Alias):** `FROM` 절에 서브쿼리를 쓸 때는 반드시 **별칭** (예: `sub`) 을 지정해야 에러가 나지 않는 DB들이 많습니다.
* **실행 순서:** 괄호 안의 서브쿼리가 먼저 실행되어 "날짜별 합계"를 만들고, 바깥쪽 쿼리가 그 결과를 받아 "평균"을 계산합니다.