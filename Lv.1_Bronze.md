# 1. 배우별 출연작 장르 다양성 분석

---

### DB : PostgreSQL Sample Database

---

## 1. 테이블 정보 (Schema)

**`actor`** (배우 정보)

* `actor_id`: 배우 고유 ID (PK)
* `first_name`: 이름
* `last_name`: 성

| actor_id | first_name | last_name |
| --- | --- | --- |
| 1 | Penelope | Guiness |
| 2 | Nick | Wahlberg |
| ... | ... | ... |

**`film_actor`** (영화-배우 출연 정보)

* `actor_id`: 배우 ID (FK)
* `film_id`: 영화 ID (FK)

| actor_id | film_id |
| --- | --- |
| 1 | 1 |
| 1 | 23 |
| ... | ... |

**`film_category`** (영화-카테고리 연결)

* `film_id`: 영화 ID (FK)
* `category_id`: 카테고리 ID (FK)

| film_id | category_id |
| --- | --- |
| 1 | 6 |
| 2 | 11 |
| ... | ... |

**`category`** (카테고리 정보)

* `category_id`: 카테고리 ID (PK)
* `name`: 장르 이름 (예: Action, Comedy)

| category_id | name |
| --- | --- |
| 1 | Action |
| 2 | Animation |
| ... | ... |

---

## 2. 문제 상황 (Scenario)

**[영화사 캐스팅 담당자의 요청]**
"한 가지 장르에 국한되지 않고, 다양한 장르를 소화하는 **다재다능한 배우** 를 찾고 싶습니다.
모든 배우를 대상으로 하되, **출연작이 총 20편 이상인 '베테랑 배우'** 만 선별해 주세요.

선별된 배우들에 대해 **이름** (`first_name`), **성** (`last_name`), **총 출연 영화 수** (`total_films`), 그리고 출연한 영화들이 속한 **서로 다른 장르의 개수** (`genre_diversity`) 를 집계해 주시기 바랍니다."

---

## 3. 원하는 결과 (Expected Output)

* **장르 다양성** (`genre_diversity`) 이 높은 순서대로 내림차순 정렬하세요.
* 만약 장르 다양성이 같다면, **총 출연 편수** (`total_films`) 가 많은 순서대로 내림차순 정렬하세요.

| first_name | last_name | total_films | genre_diversity |
| --- | --- | --- | --- |
| GINA | DEGENERES | 42 | 16 |
| WALTER | DORN | 35 | 16 |
| SANDRA | KILMER | 37 | 15 |
| ... | ... | ... | ... |

---

#### 힌트 (고민을 돕는 질문)

* **조건의 위치:** "출연작이 20편 이상"이라는 조건은 데이터를 그룹화하기 전에 걸러야 할까요(`WHERE`), 아니면 그룹화가 끝난 집계 결과에 대해 걸러야 할까요(`HAVING`)?
* **중복 제거:** 그냥 `COUNT(category_id)`를 사용하면 단순히 영화 편수와 동일한 값이 나올 수 있습니다. "서로 다른" 장르의 개수만 세려면 집계 함수 안에 어떤 키워드를 추가해야 할까요?
* **테이블 조인:** 배우, 영화, 카테고리 정보를 모두 연결하기 위해 총 4개의 테이블(`actor`, `film_actor`, `film_category`, `category`)을 연결해야 합니다.

---

# 2. 대용량 테이블 전체 조회(Full Scan) 발생 원인 분석

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`user_access_logs`** (사용자 접속 로그)

* **데이터 건수**: 약 1,000만 건 (대용량)
* `log_id`: 로그 고유 번호 (PK)
* `user_id`: 사용자 ID (FK)
* `access_timestamp`: 접속 일시 (TIMESTAMP)
* `ip_address`: 접속 IP
* **인덱스 정보**: **접속 일시** (`access_timestamp`) 컬럼에 B-Tree 인덱스 (`idx_access_timestamp`) 생성됨

---

## 2. 문제 상황 (Scenario)

**[백엔드 개발 팀장의 요청]**
"2025년 2월 1일 하루 동안 발생한 접속 기록을 카운트하기 위해 쿼리를 작성했는데, 인덱스가 있음에도 불구하고 **1,000만 건 전체를 뒤지는 Full Table Scan** 이 발생하여 속도가 너무 느립니다.

아래 작성된 **수정 전 쿼리** (Bad SQL) 를 분석하여, 인덱스 (`idx_access_timestamp`) 를 효율적으로 탈 수 있는 **Range Scan** 방식으로 `WHERE` 절을 튜닝해 주세요.
(단, 결과값은 원본 쿼리와 정확히 동일해야 합니다.)"

**[수정 전 쿼리 (Bad SQL)]**

```sql
SELECT count(*)
FROM user_access_logs
WHERE TO_CHAR(access_timestamp, 'YYYY-MM-DD') = '2025-02-01';

```

---

#### 힌트 (고민을 돕는 질문)

* **좌변 가공 금지** (SARGable): `TO_CHAR(col, ...)` 처럼 컬럼(좌변)에 함수를 씌우면 인덱스를 사용할 수 없습니다. 컬럼을 원형 그대로 유지하려면 우변(비교할 값)을 어떻게 변경해야 할까요?
* **시간 범위 설정:** '2025-02-01' 하루 전체를 의미하려면 시간 범위는 `2025-02-01 00:00:00` 부터 언제까지여야 할까요?
* **연산자 선택:** `BETWEEN` 을 사용할 수도 있고, `>=` 와 `<` 연산자를 조합할 수도 있습니다. 시간 데이터(TIMESTAMP)의 특성상 어느 쪽이 더 정확하고 안전할까요? (예: 2월 2일 0시 0분 0초 데이터의 포함 여부)

---

# 3. 특정 쿼리의 성능 저하 병목 구간 진단

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`users`** (회원 정보)

* **데이터 건수**: **약 500만 건**
* `user_id` (PK): 회원 번호
* `user_name`: 이름
* `mobile_no`: 휴대전화 번호 (**VARCHAR(20)** 타입)
* **데이터 예시**: `'01012345678'`, `'01098765432'` (하이픈 없이 숫자만 문자로 저장됨)
* **인덱스 정보**: `mobile_no` 컬럼에 대해 **B-Tree 인덱스** (`idx_users_mobile_no`) 생성됨

---

## 2. 문제 상황 (Scenario)

**[고객 센터의 요청]**
"특정 전화번호 (`01012345678`) 를 가진 회원을 긴급하게 검색해야 합니다.
그런데 신입 개발자가 작성한 쿼리를 실행했더니, **인덱스가 있음에도 불구하고 Full Table Scan** (**테이블 전체 스캔**) 이 발생하여 조회가 3초 이상 지연되고 있습니다.

아래 작성된 **수정 전 쿼리** (Bad SQL) 를 분석하여, `idx_users_mobile_no` 인덱스를 사용하여 **0.01초 내에 즉시 조회** (`Index Seek`) 될 수 있도록 `WHERE` 절을 올바르게 수정해 주세요."

**[수정 전 쿼리 (Bad SQL)]**

```sql
SELECT user_id, user_name, mobile_no
FROM users
WHERE mobile_no = 01012345678;

```

---

#### 힌트 (고민을 돕는 질문)

* **묵시적 형변환** (Implicit Type Conversion): DB 엔진은 비교 연산 시 데이터 타입이 다르면 우선순위가 높은 쪽(**숫자**)으로 변환합니다. `WHERE mobile_no = 01012345678` 은 내부적으로 `WHERE CAST(mobile_no AS NUMBER) = 01012345678` 처럼 처리될 수 있습니다. 이렇게 **좌변** (`컬럼`) 이 가공되면 인덱스를 사용할 수 있을까요?
* **타입 일치:** `mobile_no` 컬럼은 `VARCHAR` 입니다. 반면, `WHERE` 절에 입력된 `01012345678` 은 SQL에서 **어떤 타입** (숫자 vs 문자) 으로 인식될까요?
* **해결책:** 타입을 일치시켜 인덱스를 태우려면, 비교하는 값(우변)을 어떻게 수정해야 할까요? (따옴표 활용)

---

# 4. 인덱스 적용 실패 및 비효율적 스캔 원인 규명

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`customer`** (고객 정보)

* **데이터 건수**: **약 60만 건**
* `customer_id` (PK): 고객 ID
* `last_name`: **고객의 성** (`last_name`) - **B-Tree 인덱스 있음** (`idx_last_name`)
* `email`: 이메일

---

## 2. 문제 상황 (Scenario)

**[마케팅 팀의 요청]**
"성(Last Name)이 **'RO' 로 시작하는** 모든 고객 (예: **Ro**ss, **Ro**gers, **Ro**driguez 등) 을 찾아서 캠페인 메일을 보내려 합니다.
개발자가 아래와 같이 쿼리를 작성했는데, 역시나 인덱스를 타지 않고 **Full Table Scan** 이 발생하고 있습니다."

**[수정 전 쿼리 (Bad SQL)]**

```sql
SELECT customer_id, last_name, email
FROM customer
WHERE LEFT(last_name, 2) = 'RO';

```

**[문제 사양]**

1. 위 쿼리는 `last_name` 컬럼의 앞 2글자를 잘라내는 함수 (`LEFT`) 를 사용했기 때문에 인덱스를 사용할 수 없습니다.
2. 함수를 사용하지 않고, 인덱스를 활용하여 **'RO' 로 시작하는 이름** 을 검색하도록 쿼리를 수정해 주세요.
3. 결과는 원본 쿼리와 동일해야 합니다.

---

#### 힌트 (고민을 돕는 질문)

* `LEFT(col, 2) = 'RO'`는 "왼쪽 2글자가 RO와 같다"는 뜻입니다. 이를 `LIKE` 연산자로 표현하면 어떻게 될까요?
* 와일드카드 (`%`) 를 어디에 붙여야 인덱스의 정렬 순서를 깨뜨리지 않고 검색할 수 있을까요?

---

# 5. 심판별 채점 결과 비교 데이터 추출

---

### DB :

---

## 1. 테이블 정보 (Schema)

**`game_scores`** (게임 점수)

* `player_name`: 플레이어 이름
* `score`: 점수

| player_name | score |
| --- | --- |
| A | 100 |
| B | 100 |
| C | 90 |
| D | 80 |

---

## 2. 문제 상황 (Scenario)

**[상황]**
게임 대회가 끝났습니다. **A** 와 **B** 가 동점으로 공동 1등입니다.
이제 동메달(3등?)을 누구에게 줄지 결정해야 하는데, 심판진 의견이 갈렸습니다.

* **심판 1** (올림픽 방식): "공동 1등이 2명이니까, 다음 사람은 **3등** 이다." (1등, 1등, 3등, 4등...)
* **심판 2** (일반적인 순위): "공동 1등이 있어도 다음 사람은 **2등** 이지." (1등, 1등, 2등, 3등...)
* **심판 3** (줄 세우기): "동점자는 없다. 가나다순으로라도 잘라서 무조건 **1, 2, 3, 4등** 을 매겨라." (1등, 2등, 3등, 4등...)

**[문제]**
위 3명의 심판이 원하는 결과를 내주는 **윈도우 함수 3대장** 의 이름을 각각 짝지어 주세요.

1. **심판 1** (건너뛰기): 1등, 1등, **3등** ... → 함수 이름: `______()`
2. **심판 2** (빈틈없이): 1등, 1등, **2등** ... → 함수 이름: `______()`
3. **심판 3** (고유번호): 1등, 2등, 3등 ... → 함수 이름: `______()`

*(힌트: `RANK`, `DENSE_RANK`, `ROW_NUMBER` 중 하나씩 들어갑니다.)*

---

#### 힌트 (단어의 뉘앙스)

* **Dense:** '빽빽한', '밀집한'이라는 뜻입니다. 순위 사이에 빈틈(3등으로 점프) 없이 꽉 채운다는 느낌을 생각해 보세요.
* **Row Number:** 말 그대로 행(Row)에 번호(Number)를 1, 2, 3, 4... 붙이는 겁니다. 동점자 사정은 봐주지 않습니다.